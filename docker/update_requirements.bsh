#!/usr/bin/env bash

set -eu

source ${VIP_VSI_DIR}/linux/ask_question.sh

if [ "$(id -u)" == "0" ]; then
  apt-get update
  apt-get install -y ca-certificates wget --no-install-recommends
  pip install pip==8.1.2
  #This script works specifically with this version, no idea if it's forwards compatible
  exec /celery_entrypoint.bsh "$0" "${@}"
fi

#comma separated list of binary only packages
PIP_BINARY_ONLY="entrypoints"

function get_packages()
{
  pip download -v -d /tmp "${@}" --no-binary :all: --only-binary "${PIP_BINARY_ONLY}" |
    tee >(cat 1>&2) |
    #this is a nasty tee hack due to https://github.com/docker/docker/issues/6880
    
    grep -E '^  Using version |^Collecting' |
    #Grep only the lines with useful information, pip 8.1.2 specific!

    sed -r -e 's|^Collecting ([^ =<>~!]+).*|\1|' | 
    #Remove all but the package name, including any "extra"s but not including version restraint

    sed '$!N;s|\n  Using||;P;D' | 
    #Combine lines starthing with Using

    awk '{print $1 "@" $3}'
    #Print out the package name from the first sed and the version number which 
    #comes after [Using] version

    #Prone to not print out extras or custom urls
    #grep -E '^  [0-9]+ location\(s\) to search for versions of |^  Using version ' | \
    #sed 'N;s/\n//' | \
    ##Combine every two lines
    #awk '{print substr($8, 1, length($8)-1) " " $11}'

    #Does not work on binary packages, but does work on non-pip packages
    #grep '^  Source in ' | \
    #awk '{gsub("[=<>!~].*", "", $10); print $10 " " substr($6, 1, length($6)-1)}'
}

#Thanks cffi for this :(
if ! command -v x86_64-linux-gnu-gcc > /dev/null; then
  cp /bin/true /tmp/x86_64-linux-gnu-gcc
  export PATH="${PATH}:/tmp"
fi

#I do NOT use the --pre option for any of the pip commands, so pre-releases are
#not considered. The easiest way to add a pre-release is to use the custom
#requirements file

function write_requirement()
{ #filename package_info(form of name@version)
  package_name=${2%%@*}
  version=${2#*@}
  if [ "${version}" == "" ]; then
    echo "${package_name}" >> "$1"
  else
    echo "${package_name}==${version}" >> "$1"
  fi
}

function update_requirements()
{ # input_requirements_file output_requirements_file [other args]
  local input=$1
  local output=$2
  shift 2
  for package in $(get_packages -r "${input}" ${@+"${@}"}); do
    write_requirement "${output}" "${package}"
  done
}

function update_main_requirements()
{
  : > "$1.new"
  # while IFS='' read -r line || [[ -n "$line" ]]; do
  #   main_package="${line%%==*}"
  #   for package in $(get_packages ${main_package} --no-deps); do
  #     write_requirement "$1.new" "${package}"
  #   done
  # done < "$1"

  update_requirements "$1" "$1.new" --no-deps

  #Can't use wc -l here cause its buggy with blank lines, counting "newlines" not lines
  if [ "$(grep -cv '^\s*$' "$1")" == \
       "$(grep -cv '^\s*$' "$1.new")" ]; then
    mv -f "$1.new" "$1"
  else
    echo "Something went wrong"
    exit 1
  fi
}

function update_derived_requirements()
{ # main_requirements.txt custom_requirements.txt derived_requirements.txt
  echo "#Autogenerated file. Please run just update-python-requirements to update" > "$3"

  if [ -f "$2" ]; then
    update_requirements "$2" "$3"
  fi
  update_requirements "$1" "$3"

#   #Does not support one dependency depending on another when both in the custom list.
#   if [ -f $2 ]; then
#     while IFS='' read -r line || [[ -n "$line" ]]; do
# #      name_version_from_filename $line
# #      custom_package="${package}"
# #      echo $line >> "$3"
#       for pacakge in $(get_packages "${line}"); do

#         #name_version_from_filename "${filename}"
#         #if [ "${package}" != "${custom_package}" ]; then
#         #  echo "${package}==${version}" >> "$3"
#         #fi
#       done
#     done < "$2"
#   fi

#   for filename in $(get_filenames -r "$1"); do
#     name_version_from_filename "${filename}"
#     echo "${package}==${version}" >> "$3"
#   done
}

files=(common flower uwsgi nginx notebook_1 notebook_2)

for f in "${files[@]}"; do
  update_main_requirements "${VIP_PROJECT_DIR}/docker/requirements_${f}.txt"
done

for f in "${files[@]}"; do
  echo "### ${f} ###"
  cat "${VIP_PROJECT_DIR}/docker/requirements_${f}.txt"
done

echo "(Hint: You can edit the files before saying yes)"
ask_question "Do these requirements look ok?" requirements "y"
if [ "${requirements}" == "0" ]; then
  exit 1
fi

for f in "${files[@]}"; do
  update_derived_requirements "${VIP_PROJECT_DIR}/docker/requirements_${f}.txt" \
                              "${VIP_PROJECT_DIR}/docker/requirements_${f}_custom.txt" \
                              "${VIP_PROJECT_DIR}/docker/requirements_${f}_derived.txt"
done