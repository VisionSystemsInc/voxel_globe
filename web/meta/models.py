from django.contrib.gis.db import models
from django.core.exceptions import FieldError
from django.db.transaction import atomic;
import json;

from uuid import uuid4;

import tasks

# Create your models here.

PIXEL_FORMAT = (('f', 'Float'), ('d', 'Double'), ('q', 'Quadruple'), 
                 ('b', 'Byte 8'), ('s', 'Short 16'), 
                 ('i', 'Integer 32'), ('l', 'Long Integer 64'));

LENGTH_UNIT = (('m', 'Meters'), ('f', 'Feet'))
ANGLE_UNIT = (('r', 'Radians'), ('d', 'Degrees'))
COORDINATE_SYSTEM = (('l', 'Local Vertical Coordinate System'),
                     ('c', 'Cartesian'))
TRANSFORMATION_TYPE = (('c', 'Cartesian'),
                       ('s', 'Similarity'),
                       ('g', 'Geographic'));

MODEL_TYPE = (('vol', 'Volumentric'), ('ph', 'Polyhedral'), ('pl', 'Plane'),
              ('c', 'Cylinder'), ('pc', 'Point Cloud'))

use_geography_points = False

class Parameters:
  def __init__(self, params=None, fromStr=None):
    if fromStr:
      params = json.loads(fromStr);
    self.params = params;
  def __str__(self):
    return json.dumps(self.params)

class VipCommonModel(models.Model):
  class Meta:
    abstract = True

  #Returns the string representation of the model. Documentation says I 
  #need to do this. __unicode__ on Python 2
  def __unicode__(self):
    return '%s[%s]' % (self.name, self.id)
  
  def __repr__(self, recurse=0, indent=0):
    s = '';
    for field in self._meta.fields:
      fieldName = field.name;
      try:
        fieldValue = getattr(self, fieldName);
      except: # field.rel.to.DoesNotExist: While this WORKS, I do not understand it, so I will not use it
        fieldValue = "Error: Does Not Exist"
      if isinstance(fieldValue, models.Model):
        if recurse and isinstance(fieldValue, VipCommonModel):
          s += ' '*indent+'%s:\n' % (fieldName)
          s += fieldValue.__repr__(indent=indent+4, recurse=recurse-1);
        else:
          s += ' '*indent+'%s: %s - %s\n' % (fieldName, fieldValue._meta.model_name, unicode(fieldValue))
      else:
        s += ' '*indent+'%s: %s\n' % (fieldName, fieldValue)
        
    for field in self._meta.many_to_many:
      fieldName = field.name;
      s += ' '*indent+'%s\n' % fieldName;
      try:
        fieldValues = getattr(self, fieldName).all();
      except:
        fieldValues = [];
      for m2m in fieldValues:
        if recurse and isinstance(m2m, VipCommonModel):
          s += ' '*(indent+1)+'%s\n' % m2m;
          s += m2m.__repr__(indent=indent+2, recurse=recurse-1);
        else:
          s += ' '*(indent+2)+'%s\n' % m2m;
    return s;

class WorkflowInstance(VipCommonModel):
  name = models.TextField();

class ServiceInstance(VipCommonModel):
  workflow = models.ForeignKey('WorkflowInstance', blank=True, null=True);
  inputs = models.TextField('Inputs');
  outputs = models.TextField('Outputs');
  
  #inputId m2m generic foriegn key
  #outputId m2m generic foriegn key
  
  user = models.CharField(max_length=32);
  entryTime = models.DateTimeField(auto_now_add = True);
  finishTime = models.DateTimeField(auto_now = True); 
  
  status = models.CharField(max_length=32);
  
  serviceName = models.CharField(max_length=128);
  
  def __unicode__(self):
    return '%s [%s]' % (self.serviceName, self.id)

#Abtract common model
class VipObjectModel(VipCommonModel):
  service = models.ForeignKey('ServiceInstance');
  name = models.TextField();
  objectId = models.CharField('Object ID', max_length=36);
  newerVersion = models.ForeignKey('self', null=True, blank=True);

  class Meta:
    abstract = True

  def getProvenance(self):
    s = ''
    if self.service.workflow:
      s += 'Workflow %s' % (self.service.workflow)

    s += 'Generated by %s\n' % (self.service)
    s += '  Inputs: %s\n' % str(self.service.inputs)
    s += '  Outputs: %s\n' % str(self.service.outputs)

    s += 'Object History (newest first)\n'
    objects = self._meta.model.objects.filter(objectId=self.objectId)
    obj = objects.filter(newerVersion_id=None)[0]
    while 1:
      s += '  %s generated by %s\n' % (obj, obj.service);
      obj = objects.filter(newerVersion_id=obj.id)
      if obj:
        obj=obj[0];
      else:
        break;
    return s;
    
  @classmethod
  def taskAddSync(cls, *args, **kwargs):
    ''' This is DONE, however will NOT currently work. It has to do with some python
        thing where a class can be loaded twice, and thus have a different ID, and
        super fails a basic "isinstance" test. I BELEIVE this will start working
        once I properly import celery into django, and load celery in a shared
        class space, but I do not want to do that NOW. SO I will continue to use
        the hack tasks until that is done. If this does NOT solve the problem,
        I will either 
        1) Have to give up on this neat trick
        2) Handle super myself?
        3) Read more on http://thingspython.wordpress.com/2010/09/27/another-super-wrinkle-raising-typeerror/'''
#    @tasks.app.task(base=tasks.VipTask, bind=True)
#This too is broken until I do it right
    def __taskAddSync(self, *args, **kwargs):
      obj = cls.create(*args, **kwargs);
      obj.service_id = self.request.id;
      obj.save();
      return obj.id;
    return __taskAddSync.apply(*args, **kwargs)

  @classmethod
  def taskAddAsync(cls, *args, **kwargs):
#    @tasks.app.task(base=tasks.VipTask, bind=True)
#This too is broken until I do it right
    def __taskAdd(self, *args, **kwargs):
      obj = cls.create(*args, **kwargs);
      obj.service_id = self.request.id;
      obj.save();
      return obj.id;
    return _taskAdd.apply_async(*args, **kwargs)

  ''' I never finished this. Finish when above is fixed ''' 
  # @classmethod
  # @tasks.app.task(base=tasks.VipTask, bind=True)
  # def taskUpdate(self, cls, *args, **kwargs):
    # print self.request.id
    # print cls 
    # print args
    # print kwargs
    
  @classmethod
  def create(cls, *args, **kwargs):
    '''Create an new object, autogenerating a uuid for object ID'''
    obj = cls(*args, **kwargs);
    obj.objectId = str(uuid4());
    return obj;
  
  def _findNewest(self):
    return self._meta.model.objects.get(objectId=self.objectId, newerVersion=None);
  
  @atomic
  def __update(self, *args, **kwargs):
    '''Write updates to versioning 
       
       This is the real tricky part, so make it atomic'''
    newest = self._findNewest();
    print 'newest is', newest
    self.newerVersion_id = None;
    #The most uptodate is ALWAYS the newest, so it should always be none
    self.save(*args, **kwargs);
    newest.newerVersion_id = self.id;
    newest.save();

  def update(self, _auto_save=True, **kwargs):
    '''Update record and optionally save, turning object into new record

       This will allow you to update any of the fields except m2m fields which
       Must be manually modified, since that is not a simple update.
       
       Automatically saves unless _auto_save is set to False'''

    self.id = None;
    #You know, the developer COULD set id, I mean, that would be BAD, but hey, 
    #whatever. I won't prevent it.

    for name, val in kwargs.iteritems():
      field, model, direct, m2m = self._meta.get_field_by_name(name)
      if not direct or m2m:
        raise FieldError('Cannot update model field %r (only non-relations and foreign keys permitted).' % field)
      setattr(self, name, val);

    if _auto_save:
      self.__update();
    else:
#      import rpdb2;
#      rpdb2.start_embedded_debugger('vsi')  
      setattr(self, '_update_save', True);

  def save(self, *args, **kwargs):
    '''Save record, and update if internal flag is set, then call built in save'''
    if getattr(self, '_update_save', False):
      self._update_save = False;
      self.__update(*args, **kwargs);
    else:
      super(VipObjectModel, self).save(*args, **kwargs);
  
  @atomic
  def delete(self, using=None, check_is_used=True):
    '''Remove this version of the object ID. 
    
       This function currently does NOT Search all other tables for references, 
       but will in the future. Maybe not.
       
       The check_is_used is a placeholder to skip the check the ServiceInstance
       table to see if this instance is refered to. This is useful to skip if
       there is a global maintanence routine that will have already checked this
       and there is no reason to check here again, for speed.'''
    
    if check_is_used:
      pass
    
    parent = self._meta.model.objects.filter(objectId=self.objectId, newerVersion_id=self.id);
    
    if parent:
      parent[0].newerVersion_id = self.newerVersion_id;
      parent[0].save();

    super(VipObjectModel, self).delete(using);

class Session(VipCommonModel):
  '''Model to track everything in a processing session
  
     This is Common Model and not Object model because I expect it to be ever
     changing. The session shall NOT be passed along to celery. Rather, the
     values in the session are USED as the input parameters to a celery task.
     While this may be annoying, it allows us to not need to object track 
     Session while still maintaining out repeatablity and trackability.'''

  origin = models.ForeignKey('CoordinateSystem')
  xRegion =  models.FloatField();
  yRegion =  models.FloatField();
  zRegion =  models.FloatField();
  name = models.CharField(max_length=32);

###  imageCollection = models.ForeignKey('ImageCollection')
  cameraCollection = models.ForeignKey('CameraCollection');

class CameraCollection(VipObjectModel):
  cameras = models.ManyToManyField('Camera');

class Camera(VipObjectModel):
  focalLengthU = models.FloatField();
  focalLengthV = models.FloatField();
  principlePointU = models.FloatField();
  principlePointV = models.FloatField();
  coordinateSystem = models.ForeignKey('CoordinateSystem')
  #Should the camera point to the image instead? Meaning Camera Collection only
  #and no image Collection... Ask Joe

''' Coordinate systems '''
class CoordinateSystem(VipObjectModel):
  csType = models.CharField(max_length=1, choices=COORDINATE_SYSTEM)
  srid = models.IntegerField();

class CartisianCoordinateSystem(CoordinateSystem):
  xUnit = models.CharField(max_length=1, choices=LENGTH_UNIT)
  yUnit = models.CharField(max_length=1, choices=LENGTH_UNIT)
  zUnit = models.CharField(max_length=1, choices=LENGTH_UNIT)

class GeoreferenceCoordinateSystem(CoordinateSystem):
  xUnit = models.CharField(max_length=1, choices=LENGTH_UNIT+ANGLE_UNIT)
  yUnit = models.CharField(max_length=1, choices=LENGTH_UNIT+ANGLE_UNIT)
  zUnit = models.CharField(max_length=1, choices=LENGTH_UNIT+ANGLE_UNIT)
  location = models.PointField(dim=3)
  
  def toCartisianCoordinateSystem(self, origin):
    ''' Returns the transformation to go from this Georeference Coordinate
        System to a Cartisian frame At the origin point'''
    pass;
  
  objects = models.GeoManager()
  #I need a GeoManager for PoostGIS onjects

''' Coordinate Transforms '''

class CoordinateTransform(VipObjectModel):
  coordinateSystem_from = models.ForeignKey('CoordinateSystem', related_name='coordinatetransform_from_set')
  coordinateSystem_to   = models.ForeignKey('CoordinateSystem', related_name='coordinatetransform_to_set')
  #I  need to do this for ABSTRACT, but this isn't abstract, so I don't think I need to
  #coordinateSystem_from = models.ForeignKey('CoordinateSystem', related_name='%(app_label)s_%(class)_from_related')
  #coordinateSystem_to   = models.ForeignKey('CoordinateSystem', related_name='%(app_label)s_%(class)_to_related')
  transformType = models.CharField(max_length=1, choices=TRANSFORMATION_TYPE)

class CartesianTransform(CoordinateTransform):
#   rodriguezX = models.FloatField();
#   rodriguezY = models.FloatField();
#   rodriguezZ = models.FloatField();
  rodriguezX = models.PointField();
  rodriguezY = models.PointField();
  rodriguezZ = models.PointField();
  #TOTAL HACK until I get REAL Rodriguez vectors in here, I will Store R!
  
  translationX = models.FloatField();
  translationY = models.FloatField();
  translationZ = models.FloatField();

''' The rest '''

class ImageCollection(VipObjectModel):
  images = models.ManyToManyField('Image');

class Image(VipObjectModel):
  fileFormat = models.CharField(max_length=4);
  pixelFormat = models.CharField(max_length=1, choices=PIXEL_FORMAT);
  imageWidth = models.PositiveIntegerField('Image Width (pixels)');
  imageHeight = models.PositiveIntegerField('Image Height (pixels)');
  numberColorBands = models.PositiveIntegerField('Number of Color Bands');
  imageURL = models.TextField(unique=True);
  camera = models.ForeignKey('Camera', null=True, blank=True);

class TiePoint(VipObjectModel):
  #description = models.CharField(max_length=250)
  #x = models.FloatField()
  #y = models.FloatField()
  point = models.PointField(dim=2)
  
  image = models.ForeignKey('Image', blank=False)
  geoPoint = models.ForeignKey('ControlPoint', null=True, blank=True)

  objects = models.GeoManager()

class ControlPoint(VipObjectModel):
  description = models.TextField()
  
  point = models.PointField(dim=3, geography=use_geography_points)
  apparentPoint = models.PointField(dim=3, geography=use_geography_points, null=True, blank=True)

  objects = models.GeoManager()
    
  #latitude = models.FloatField()
  #longitude = models.FloatField()
  #altitude = models.FloatField()
    
  #apparentLatitude = models.FloatField()
  #apparentLongitude = models.FloatField()
  #apparentAltitude = models.FloatField()

