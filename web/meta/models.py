from django.contrib.gis.db import models
from django.core.exceptions import FieldError
from django.db.transaction import atomic;
import json;

from uuid import uuid4;

# Create your models here.

PIXEL_FORMATS = (('f', 'Float'), ('d', 'Double'), ('q', 'Quadruple'), 
                 ('b', 'Byte 8'), ('s', 'Short 16'), 
                 ('i', 'Integer 32'), ('l', 'Long Integer 64'));

class Parameters:
  def __init__(self, params=None, fromStr=None):
    if fromStr:
      params = json.loads(fromStr);
    self.params = params;
  def __str__(self):
    return json.dumps(self.params)

class VipCommonModel(models.Model):
  class Meta:
    abstract = True

  #Returns the string representation of the model. Documentation says I 
  #need to do this. __unicode__ on Python 2
  def __unicode__(self):
    return '%s[%s]' % (self.name, self.id)
  
  def __repr__(self, recurse=0, indent=0):
    s = '';
    for field in self._meta.fields:
      fieldName = field.name;
      try:
        fieldValue = getattr(self, fieldName);
      except: # field.rel.to.DoesNotExist: While this WORKS, I do not understand it, so I will not use it
        fieldValue = "Error: Does Not Exist"
      if isinstance(fieldValue, models.Model):
        if recurse and isinstance(fieldValue, VipCommonModel):
          s += ' '*indent+'%s:\n' % (fieldName)
          s += fieldValue.__repr__(indent=indent+4, recurse=recurse-1);
        else:
          s += ' '*indent+'%s: %s - %s\n' % (fieldName, fieldValue._meta.model_name, unicode(fieldValue))
      else:
        s += ' '*indent+'%s: %s\n' % (fieldName, fieldValue)
        
    for field in self._meta.many_to_many:
      fieldName = field.name;
      s += ' '*indent+'%s\n' % fieldName;
      try:
        fieldValues = getattr(self, fieldName).all();
      except:
        fieldValues = [];
      for m2m in fieldValues:
        if recurse and isinstance(m2m, VipCommonModel):
          s += ' '*(indent+1)+'%s\n' % m2m;
          s += m2m.__repr__(indent=indent+2, recurse=recurse-1);
        else:
          s += ' '*(indent+2)+'%s\n' % m2m;
    return s;

class WorkflowInstance(VipCommonModel):
  name = models.TextField();

class ServiceInstance(VipCommonModel):
  workflow = models.ForeignKey('WorkflowInstance', blank=True, null=True);
  inputs = models.TextField('Inputs');
  outputs = models.TextField('Outputs');
  
  #inputId m2m generic foriegn key
  #outputId m2m generic foriegn key
  
  user = models.CharField(max_length=32);
  entryTime = models.DateTimeField(auto_now_add = True);
  finishTime = models.DateTimeField(auto_now = True); 
  
  status = models.CharField(max_length=32);
  
  serviceName = models.CharField(max_length=128);
  
  def __unicode__(self):
    return '%s [%s]' % (self.serviceName, self.id)

#Abtract common model
class VipObjectModel(VipCommonModel):
  service = models.ForeignKey('ServiceInstance');
  name = models.TextField();
  objectId = models.CharField('Object ID', max_length=36);
  newerVersion = models.ForeignKey('self', null=True, blank=True);

  class Meta:
    abstract = True

  def getProvenance(self):
    s = ''
    if self.service.workflow:
      s += 'Workflow %s' % (self.service.workflow)

    s += 'Generated by %s\n' % (self.service)
    s += '  Inputs: %s\n' % str(self.service.inputs)
    s += '  Outputs: %s\n' % str(self.service.outputs)

    s += 'Object History (newest first)\n'
    objects = self._meta.model.objects.filter(objectId=self.objectId)
    obj = objects.filter(newerVersion_id=None)[0]
    while 1:
      s += '  %s generated by %s\n' % (obj, obj.service);
      obj = objects.filter(newerVersion_id=obj.id)
      if obj:
        obj=obj[0];
      else:
        break;
    return s;
  
  @classmethod
  def create(cls, *args, **kwargs):
    '''Create an new object, autogenerating a uuid for object ID'''
    obj = cls(*args, **kwargs);
    obj.objectId = str(uuid4());
    return obj;
  
  def _findNewest(self):
    return self._meta.model.objects.get(objectId=self.objectId, newerVersion=None);
  
  @atomic
  def __update(self, *args, **kwargs):
    '''Write updates to versioning 
       
       This is the real tricky part, so make it atomic'''
    newest = self._findNewest();
    print 'newest is', newest
    self.newerVersion_id = None;
    #The most uptodate is ALWAYS the newest, so it should always be none
    self.save(*args, **kwargs);
    newest.newerVersion_id = self.id;
    newest.save();

  def update(self, _auto_save=True, **kwargs):
    '''Update record and optionally save, turning object into new record

       This will allow you to update any of the fields except m2m fields which
       Must be manually modified, since that is not a simple update.
       
       Automatically saves unless _auto_save is set to False'''

    self.id = None;
    #You know, the developer COULD set id, I mean, that would be BAD, but hey, 
    #whatever. I won't prevent it.

    for name, val in kwargs.iteritems():
      field, model, direct, m2m = self._meta.get_field_by_name(name)
      if not direct or m2m:
        raise FieldError('Cannot update model field %r (only non-relations and foreign keys permitted).' % field)
      setattr(self, name, val);

    if _auto_save:
      self.__update();
    else:
#      import rpdb2;
#      rpdb2.start_embedded_debugger('vsi')  
      setattr(self, '_update_save', True);

  def save(self, *args, **kwargs):
    '''Save record, and update if internal flag is set, then call built in save'''
    if getattr(self, '_update_save', False):
      self._update_save = False;
      self.__update(*args, **kwargs);
    else:
      super(VipObjectModel, self).save(*args, **kwargs);
  
  @atomic
  def delete(self, using=None, check_is_used=True):
    '''Remove this version of the object ID. 
    
       This function currently does NOT Search all other tables for references, 
       but will in the future. Maybe not.
       
       The check_is_used is a placeholder to skip the check the ServiceInstance
       table to see if this instance is refered to. This is useful to skip if
       there is a global maintanence routine that will have already checked this
       and there is no reason to check here again, for speed.'''
    
    if check_is_used:
      pass
    
    parent = self._meta.model.objects.filter(objectId=self.objectId, newerVersion_id=self.id);
    
    if parent:
      parent[0].newerVersion_id = self.newerVersion_id;
      parent[0].save();

    super(VipObjectModel, self).delete(using);
          
class ImageCollection(VipObjectModel):
  images = models.ManyToManyField('Image');

class Image(VipObjectModel):
  fileFormat = models.CharField(max_length=4);
  pixelFormat = models.CharField(max_length=1, choices=PIXEL_FORMATS);
  imageWidth = models.PositiveIntegerField('Image Width (pixels)');
  imageHeight = models.PositiveIntegerField('Image Height (pixels)');
  numberColorBands = models.PositiveIntegerField('Number of Color Bands');
  imageURL = models.TextField(unique=True);

class ImageTiePoint(VipObjectModel):
  #description = models.CharField(max_length=250)
  x = models.FloatField()
  y = models.FloatField()

  image = models.ForeignKey('Image', blank=False)
  geoPoint = models.ForeignKey('GeoTiePoint', null=True, blank=True)

class GeoTiePoint(VipObjectModel):
  description = models.TextField()
    
  latitude = models.FloatField()
  longitude = models.FloatField()
  altitude = models.FloatField()
    
  apparentLatitude = models.FloatField()
  apparentLongitude = models.FloatField()
  apparentAltitude = models.FloatField()

